# Python コーディング規約 (Modern & Zero-Fat)

本プロジェクトにおける Python コードの品質、一貫性、および保守性を最大化するための規約。

## 1. ツールチェーン

### uv (Package & Project Management)
- **依存関係管理**: すべてのパッケージは `uv add` で管理し、`pyproject.toml` と `uv.lock` を常に同期させる。
- **実行**: スクリプトの実行は `uv run python -m src.main` の形式で行い、仮想環境（`.venv`）を介すること。
- **同期**: 環境構築時は `uv sync` を使用する。

### 静的解析・フォーマット: Ruff & Pyright
- **Lint**: `task lint` でフォーマット、Lint、型チェックを一括実行。
- **構成**: `pyproject.toml` で全 16 種の厳格なルール（TRY, PL, ERA等）を有効化。

### Pydantic v2 (Data Models)
- **モデル定義**: 外部データや構成情報は `src/models.py` に `BaseModel` を継承したクラスとして定義する。
- **バリデーション**: `Annotated` を活用し、型ヒントと制約を統合する。
- **操作**: オブジェクトの生成には `model_validate`、辞書出力には `model_dump` を原則使用する。
- **不変性**: 可能な限り `model_config = {"frozen": True}` を検討し、副作用を防ぐ。

### Pylance / Type Hints (Static Analysis)
- **型ヒント**: Python 3.11 以上の機能をフル活用し、すべての変数・引数・戻り値に型を付与する。
- **Any 型の禁止**: `typing.Any` の使用を厳禁とする。型の特定が困難な場合は、`object`, `Protocol`, または適切な `Union` を検討すること。
- **`typing.Self`**: クラスメソッドの戻り値等で自身の型を指す場合に積極的に使用する。
- **Type Checking Mode**: `basic` 以上の設定を推奨し、警告を無視しない。

## 2. Zero-Fat 原則 (コア思想)

「削ぎ落とすことで、より堅牢になる」という思想を徹底する。

### エラーハンドリング禁止
- **Fail Fast**: `try-except` によるエラー隠蔽を一切禁止する。問題が発生した場合は即座にクラッシュ（例外送出）させ、パイプラインを停止させる。
- **理由**: 原因不明のまま「とりあえず動く」状態を排除し、根本的な修正を促すため。

### コメント・ドックストリング禁止
- **Self-Documenting Code**: コード自体がその目的を明確に語るべきである。
- **命名**: 関数（`snake_case`）、クラス（`PascalCase`）、定数（`UPPERCASE`）に適切な名前を付け、ロジックをシンプルに保つ。

### ハードコード排除
- **外部構成**: 動的な値、資格情報、マジックナンバーはすべて `config.yaml` に分離し、`src/config.py` 経由でアクセスする。

### リトライ・タイムアウトの排除
- **不確実性の排除**: 通信や処理のリトライロジック、恣意的なタイムアウト設定を禁止する。
- **理由**: ネットワーク層や OS 層の自然な挙動に任せ、アプリケーションレベルで複雑な状態管理を行わない。

### データ所有権と不変性 (Ownership & Immutability)
- **論理的所有権**: Python には言語レベルの所有権はないが、特定のオブジェクトの「状態」を誰が管理するかを明確にする。
- **不変性の優先**: 可能な限り `tuple`, `frozenset`, `NamedTuple`, または Pydantic の `frozen` モデルを使用し、予期せぬ副作用を排除する。
- **値の受け渡し**: 引数としてミュータブルなオブジェクト（`list`, `dict` 等）を渡す場合は、受け手側で変更しないことを原則とする。変更が必要な場合は明示的にコピーを作成する。

### デコレータの活用
- **関心の分離**: ロギング、認証、バリデーションなどの横断的な関心事はデコレータとして分離し、関数本体の「成功パス」をクリーンに保つ。
- **推奨**: 複雑な条件分岐をデコレータに逃がすことで、メインロギックの可読性を高めるアプローチを積極的に採用する。

### 成功パス（Success Path）のみの記述
- **ロジックの純粋化**: 正常系（ゴールに到達するパス）のみを平易に記述する。
- **構成**: 小さく単一責任の関数を合成（Compose）して全体のワークフローを構築する。

## 3. 代替ツールの選定と検討 (Alternative Choices)

本プロジェクトでは最新の Rust 製ツールを中心に据えているが、要件に応じて以下の代替手段も考慮する。

### 型チェック: Pyright vs. ty (beta)
- **現状**: Microsoft 製の `Pyright` (Pylance) を標準とする。安定性と VS Code との親和性が高いため。
- **将来**: Astral 製の **`ty`** を注視する。Rust 製で `Pyright` よりさらに 10〜100 倍高速とされるが、現在はベータ版である。
- **コマンド**: `uvx ty check` または `uv run ty check` で実行可能。

### パッケージ管理: uv vs. Poetry/PDM
- **uv**: 速度と単一バイナリによる簡潔さを優先。本プロジェクトの標準。
- **Poetry**: ライブラリ公開や複雑な依存関係解決が必要な場合に検討。
- **PDM**: PEP 規格への厳格な準拠が必要な場合に検討。

### データバリデーション: Pydantic vs. msgspec
- **Pydantic**: エコシステムの広さと機能の豊富さを優先。
- **msgspec**: パフォーマンスがクリティカルな超高速シリアライズが必要な場合に検討。

---

*最終更新日: 2026-02-22*
